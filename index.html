<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Finger Pick">
    <meta name="theme-color" content="#08080c">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Finger Pick</title>
    
    <!-- PWA Manifest inline as data URI -->
    <link rel="manifest" href="data:application/json,%7B%22name%22%3A%22Finger%20Pick%22%2C%22short_name%22%3A%22FingerPick%22%2C%22description%22%3A%22Qui%20sera%20d%C3%A9sign%C3%A9%20%3F%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22fullscreen%22%2C%22orientation%22%3A%22any%22%2C%22background_color%22%3A%22%2308080c%22%2C%22theme_color%22%3A%22%2308080c%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%2520viewBox%3D%270%25200%2520512%2520512%27%253E%253Crect%2520fill%3D%27%252308080c%27%2520width%3D%27512%27%2520height%3D%27512%27%2520rx%3D%27100%27%2F%253E%253Ccircle%2520fill%3D%27white%27%2520cx%3D%27256%27%2520cy%3D%27256%27%2520r%3D%27120%27%2F%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%2C%22purpose%22%3A%22any%20maskable%22%7D%5D%7D">
    
    <!-- Apple Touch Icon -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Crect fill='%2308080c' width='512' height='512' rx='100'/%3E%3Ccircle fill='white' cx='256' cy='256' r='120'/%3E%3C/svg%3E">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #08080c;
            touch-action: none;
            -webkit-overflow-scrolling: none;
            overscroll-behavior: none;
        }

        #app {
            width: 100%;
            height: 100%;
            position: fixed;
            inset: 0;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            background: 
                radial-gradient(ellipse at 30% 20%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(244, 63, 94, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(20, 184, 166, 0.05) 0%, transparent 60%),
                #08080c;
        }

        /* Settings button - top left */
        #settings-btn {
            position: absolute;
            top: 25px;
            left: 25px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.5);
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        #settings-btn:hover {
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.9);
        }

        #settings-btn.hidden {
            opacity: 0;
            visibility: hidden;
        }

        /* Settings modal */
        #settings-modal {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 300;
        }

        #settings-modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .settings-content {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
        }

        .settings-content h2 {
            color: rgba(255,255,255,0.9);
            font-weight: 300;
            font-size: 1.2rem;
            margin-bottom: 25px;
            letter-spacing: 0.1em;
        }

        .toggle-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 25px;
        }

        .toggle-option span {
            color: rgba(255,255,255,0.7);
            font-size: 0.95rem;
        }

        .toggle {
            width: 50px;
            height: 28px;
            background: rgba(255,255,255,0.1);
            border-radius: 14px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s ease;
        }

        .toggle.active {
            background: rgba(255,255,255,0.3);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .toggle.active::after {
            transform: translateX(22px);
        }

        .close-settings {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 10px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .close-settings:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Central waiting indicator */
        #center-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
        }

        #center-indicator.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
        }

        #center-indicator::before {
            content: '';
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.15);
            animation: pulse-hint 2s ease-in-out infinite;
        }

        @keyframes pulse-hint {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        /* Countdown ring */
        #countdown-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #countdown-ring.visible {
            opacity: 1;
        }

        #countdown-ring svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        #countdown-ring circle {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
        }

        #countdown-ring .bg {
            stroke: rgba(255,255,255,0.1);
        }

        #countdown-ring .progress {
            stroke: rgba(255,255,255,0.8);
            stroke-dasharray: 565.48;
            stroke-dashoffset: 565.48;
            transition: stroke-dashoffset 0.1s linear;
        }

        /* Finger circles - ALL WHITE */
        .finger-circle {
            position: absolute;
            width: 110px;
            height: 110px;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        opacity 0.4s ease,
                        filter 0.4s ease;
            cursor: pointer;
            background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
            box-shadow: 0 0 40px rgba(255,255,255,0.5), 0 0 80px rgba(255,255,255,0.25);
        }

        .finger-circle::before {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: 50%;
            background: inherit;
            filter: blur(20px);
            opacity: 0.6;
            z-index: -1;
        }

        .finger-circle::after {
            content: '';
            position: absolute;
            inset: 8px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8) 0%, transparent 60%);
        }

        .finger-circle.active {
            transform: translate(-50%, -50%) scale(1);
        }

        .finger-circle.eliminated {
            opacity: 0;
            filter: blur(10px);
            transform: translate(-50%, -50%) scale(0.3);
        }

        .finger-circle.winner {
            animation: winner-glow 0.6s ease infinite alternate;
            z-index: 100;
        }

        .finger-circle.blink {
            animation: blink 0.12s ease infinite;
        }

        @keyframes winner-glow {
            from {
                transform: translate(-50%, -50%) scale(1);
                filter: brightness(1);
                box-shadow: 0 0 40px rgba(255,255,255,0.6), 0 0 80px rgba(255,255,255,0.3);
            }
            to {
                transform: translate(-50%, -50%) scale(1.2);
                filter: brightness(1.3);
                box-shadow: 0 0 60px rgba(255,255,255,0.8), 0 0 120px rgba(255,255,255,0.5);
            }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        /* Winner burst effect */
        .winner-ring {
            position: absolute;
            border-radius: 50%;
            border: 3px solid white;
            opacity: 0;
            pointer-events: none;
            animation: ring-expand 1s ease-out forwards;
        }

        @keyframes ring-expand {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(4);
                opacity: 0;
            }
        }

        /* Particles - white */
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            background: white;
        }

        /* Reset button - minimal */
        #reset-btn {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.5);
            font-size: 1.3rem;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #reset-btn.visible {
            opacity: 1;
            visibility: visible;
        }

        #reset-btn:hover {
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.9);
            transform: rotate(-180deg);
        }
    </style>
</head>
<body>
    <div id="app">
        <button id="settings-btn">‚öô</button>
        
        <div id="settings-modal">
            <div class="settings-content">
                <h2>OPTIONS</h2>
                <div class="toggle-option">
                    <span>üçÄ Jamais choisi</span>
                    <div class="toggle" id="never-toggle"></div>
                </div>
                <div class="toggle-option">
                    <span>üéØ Toujours choisi</span>
                    <div class="toggle" id="always-toggle"></div>
                </div>
                <button class="close-settings" id="close-settings">OK</button>
            </div>
        </div>
        
        <div id="center-indicator"></div>
        
        <div id="countdown-ring">
            <svg viewBox="0 0 200 200">
                <defs>
                    <linearGradient id="countdown-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="#ffffff"/>
                        <stop offset="100%" stop-color="#aaaaaa"/>
                    </linearGradient>
                </defs>
                <circle class="bg" cx="100" cy="100" r="90"/>
                <circle class="progress" cx="100" cy="100" r="90"/>
            </svg>
        </div>
        
        <button id="reset-btn">‚Ü∫</button>
    </div>

    <script>
        const app = document.getElementById('app');
        const centerIndicator = document.getElementById('center-indicator');
        const countdownRing = document.getElementById('countdown-ring');
        const progressCircle = countdownRing.querySelector('.progress');
        const resetBtn = document.getElementById('reset-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const neverToggle = document.getElementById('never-toggle');
        const alwaysToggle = document.getElementById('always-toggle');
        const closeSettings = document.getElementById('close-settings');

        let fingers = new Map();
        let fingerCount = 0;
        let gameState = 'waiting';
        let countdownTimer = null;
        let countdownStart = null;
        let neverMode = false;  // Jamais choisi
        let alwaysMode = false; // Toujours choisi
        const COUNTDOWN_DURATION = 3000;
        const circumference = 2 * Math.PI * 90;

        // Settings handlers
        settingsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            settingsModal.classList.add('visible');
        });
        
        settingsBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            settingsModal.classList.add('visible');
        }, { passive: false });

        closeSettings.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            settingsModal.classList.remove('visible');
        });
        
        closeSettings.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            settingsModal.classList.remove('visible');
        }, { passive: false });

        neverToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            neverMode = !neverMode;
            neverToggle.classList.toggle('active', neverMode);
            if (neverMode) {
                alwaysMode = false;
                alwaysToggle.classList.remove('active');
            }
        });
        
        neverToggle.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            neverMode = !neverMode;
            neverToggle.classList.toggle('active', neverMode);
            if (neverMode) {
                alwaysMode = false;
                alwaysToggle.classList.remove('active');
            }
        }, { passive: false });

        alwaysToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            alwaysMode = !alwaysMode;
            alwaysToggle.classList.toggle('active', alwaysMode);
            if (alwaysMode) {
                neverMode = false;
                neverToggle.classList.remove('active');
            }
        });
        
        alwaysToggle.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            e.preventDefault();
            alwaysMode = !alwaysMode;
            alwaysToggle.classList.toggle('active', alwaysMode);
            if (alwaysMode) {
                neverMode = false;
                neverToggle.classList.remove('active');
            }
        }, { passive: false });

        function createFingerCircle(id, x, y) {
            const circle = document.createElement('div');
            circle.className = 'finger-circle';
            circle.dataset.id = id;
            circle.dataset.x = x;
            circle.dataset.y = y;
            
            circle.style.left = x + 'px';
            circle.style.top = y + 'px';
            
            fingerCount++;
            app.appendChild(circle);
            
            requestAnimationFrame(() => circle.classList.add('active'));
            
            return circle;
        }

        function removeFingerCircle(id) {
            const circle = app.querySelector(`.finger-circle[data-id="${id}"]`);
            if (circle) {
                circle.classList.remove('active');
                setTimeout(() => circle.remove(), 400);
            }
        }

        function getBottomRightCircle(circles) {
            // Score = x + y (higher = more bottom-right)
            let maxScore = -Infinity;
            let bottomRightCircle = null;
            
            circles.forEach(circle => {
                const x = parseFloat(circle.dataset.x);
                const y = parseFloat(circle.dataset.y);
                const score = x + y;
                if (score > maxScore) {
                    maxScore = score;
                    bottomRightCircle = circle;
                }
            });
            
            return bottomRightCircle;
        }

        function startCountdown() {
            if (fingers.size < 2) return;
            
            centerIndicator.classList.add('hidden');
            settingsBtn.classList.add('hidden');
            countdownRing.classList.add('visible');
            countdownStart = performance.now();
            
            function updateProgress() {
                if (gameState !== 'waiting') return;
                
                const elapsed = performance.now() - countdownStart;
                const progress = Math.min(elapsed / COUNTDOWN_DURATION, 1);
                const offset = circumference * (1 - progress);
                progressCircle.style.strokeDashoffset = offset;
                
                if (progress >= 1) {
                    startSelection();
                } else {
                    countdownTimer = requestAnimationFrame(updateProgress);
                }
            }
            
            countdownTimer = requestAnimationFrame(updateProgress);
        }

        function stopCountdown() {
            if (countdownTimer) {
                cancelAnimationFrame(countdownTimer);
                countdownTimer = null;
            }
            countdownRing.classList.remove('visible');
            progressCircle.style.strokeDashoffset = circumference;
            
            if (fingers.size >= 2) {
                centerIndicator.classList.add('hidden');
            } else {
                centerIndicator.classList.remove('hidden');
                settingsBtn.classList.remove('hidden');
            }
        }

        function resetCountdown() {
            stopCountdown();
            if (fingers.size >= 2 && gameState === 'waiting') {
                startCountdown();
            }
        }

        function startSelection() {
            gameState = 'selecting';
            countdownRing.classList.remove('visible');
            resetBtn.classList.add('visible');
            
            const circles = Array.from(app.querySelectorAll('.finger-circle'));
            circles.forEach(c => c.classList.add('blink'));
            
            // Find the bottom-right circle
            let targetCircle = null;
            if ((neverMode || alwaysMode) && circles.length > 1) {
                targetCircle = getBottomRightCircle(circles);
            }
            
            const remaining = [...circles];
            const blinkDuration = 1500 + circles.length * 300;
            let eliminateDelay = 300;
            
            function eliminateOne() {
                if (remaining.length <= 1) {
                    const winner = remaining[0];
                    winner.classList.remove('blink');
                    winner.classList.add('winner');
                    gameState = 'done';
                    createWinnerEffect(winner);
                    return;
                }
                
                let toEliminate;
                
                if (alwaysMode && targetCircle && remaining.includes(targetCircle)) {
                    // Always mode: eliminate anyone BUT the target
                    const others = remaining.filter(c => c !== targetCircle);
                    toEliminate = others[Math.floor(Math.random() * others.length)];
                } else if (neverMode && targetCircle && remaining.includes(targetCircle) && remaining.length === 2) {
                    // Never mode: when only 2 left, eliminate the target so they don't win
                    toEliminate = targetCircle;
                } else if (neverMode && targetCircle && remaining.includes(targetCircle)) {
                    // Never mode: randomly eliminate, but never the target (until final 2)
                    const others = remaining.filter(c => c !== targetCircle);
                    toEliminate = others[Math.floor(Math.random() * others.length)];
                } else {
                    // Normal random elimination
                    toEliminate = remaining[Math.floor(Math.random() * remaining.length)];
                }
                
                const idx = remaining.indexOf(toEliminate);
                remaining.splice(idx, 1);
                
                toEliminate.classList.remove('blink');
                toEliminate.classList.add('eliminated');
                
                eliminateDelay += 50;
                setTimeout(eliminateOne, eliminateDelay + Math.random() * 150);
            }
            
            setTimeout(eliminateOne, blinkDuration);
        }

        function createWinnerEffect(winner) {
            const rect = winner.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            
            // Expanding rings
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.className = 'winner-ring';
                    ring.style.left = cx + 'px';
                    ring.style.top = cy + 'px';
                    ring.style.width = '100px';
                    ring.style.height = '100px';
                    app.appendChild(ring);
                    setTimeout(() => ring.remove(), 1000);
                }, i * 200);
            }
            
            // Particles
            for (let i = 0; i < 60; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const size = 4 + Math.random() * 8;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.left = cx + 'px';
                particle.style.top = cy + 'px';
                
                app.appendChild(particle);
                
                const angle = (Math.PI * 2 * i) / 60 + Math.random() * 0.3;
                const velocity = 150 + Math.random() * 350;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;
                const gravity = 400;
                const startTime = performance.now();
                
                function animate(time) {
                    const dt = (time - startTime) / 1000;
                    const x = cx + vx * dt;
                    const y = cy + vy * dt + 0.5 * gravity * dt * dt;
                    const opacity = Math.max(0, 1 - dt / 1.5);
                    const scale = Math.max(0, 1 - dt / 2);
                    
                    particle.style.transform = `translate(${x - cx}px, ${y - cy}px) scale(${scale})`;
                    particle.style.opacity = opacity;
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                }
                
                requestAnimationFrame(animate);
            }
        }

        function reset() {
            gameState = 'waiting';
            fingers.clear();
            fingerCount = 0;
            stopCountdown();
            
            app.querySelectorAll('.finger-circle, .particle, .winner-ring').forEach(el => el.remove());
            
            centerIndicator.classList.remove('hidden');
            settingsBtn.classList.remove('hidden');
            resetBtn.classList.remove('visible');
        }

        // Touch events
        app.addEventListener('touchstart', (e) => {
            if (gameState !== 'waiting') return;
            
            // Ignore touches on buttons
            if (e.target.closest('#settings-btn, #settings-modal, #reset-btn')) return;
            
            e.preventDefault();
            
            for (const touch of e.changedTouches) {
                const circle = createFingerCircle(touch.identifier, touch.clientX, touch.clientY);
                fingers.set(touch.identifier, circle);
            }
            resetCountdown();
        }, { passive: false });

        app.addEventListener('touchend', (e) => {
            if (gameState !== 'waiting') return;
            
            for (const touch of e.changedTouches) {
                removeFingerCircle(touch.identifier);
                fingers.delete(touch.identifier);
            }
            resetCountdown();
        });

        app.addEventListener('touchcancel', (e) => {
            if (gameState !== 'waiting') return;
            
            for (const touch of e.changedTouches) {
                removeFingerCircle(touch.identifier);
                fingers.delete(touch.identifier);
            }
            resetCountdown();
        });

        // Mouse events for desktop
        let mouseId = 1000;
        app.addEventListener('click', (e) => {
            if (e.target === resetBtn) return;
            if (gameState !== 'waiting') return;
            
            const id = mouseId++;
            const circle = createFingerCircle(id, e.clientX, e.clientY);
            fingers.set(id, circle);
            
            circle.addEventListener('click', (ev) => {
                ev.stopPropagation();
                if (gameState !== 'waiting') return;
                removeFingerCircle(id);
                fingers.delete(id);
                resetCountdown();
            });
            
            resetCountdown();
        });

        resetBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            reset();
        });

        document.addEventListener('dblclick', (e) => e.preventDefault());
        
        // Prevent all default touch behaviors
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('gesturechange', (e) => e.preventDefault());
        document.addEventListener('gestureend', (e) => e.preventDefault());
        
        // PWA Install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
        });
        
        // Register service worker for offline support
        if ('serviceWorker' in navigator) {
            const swCode = `
                const CACHE_NAME = 'finger-pick-v1';
                self.addEventListener('install', (e) => {
                    self.skipWaiting();
                });
                self.addEventListener('activate', (e) => {
                    e.waitUntil(clients.claim());
                });
                self.addEventListener('fetch', (e) => {
                    e.respondWith(
                        caches.match(e.request).then(r => r || fetch(e.request))
                    );
                });
            `;
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swUrl).catch(() => {});
        }
    </script>
</body>
</html>
